/* ArkeoGIS - The Geographic Information System for Archaeologists
 * Copyright (C) 2015-2016 CROLL SAS
 *
 * Authors :
 *  Christophe Beveraggi <beve@croll.fr>
 *  Nicolas Dimitrijevic <nicolas@croll.fr>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// This tool convert the xml file generated by SQL Designer to a PostgreSQL importable file
// You have to name the input file "in.xml", output will be print in stdout

package main

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"strings"

	config "github.com/croll/arkeogis-server/config"
)

// Theses struct are a modelisation of the XML file
type Relation struct {
	XMLName xml.Name `xml:"relation"`
	Table   string   `xml:"table,attr"`
	Row     string   `xml:"row,attr"`
}

type Row struct {
	XMLName       xml.Name   `xml:"row"`
	Name          string     `xml:"name,attr"`
	Null          int        `xml:"null,attr"`
	Autoincrement int        `xml:"autoincrement,attr"`
	Datatype      string     `xml:"datatype"`
	Default       string     `xml:"default"`
	Comment       string     `xml:"comment"`
	Relations     []Relation `xml:"relation"`
}

type Key struct {
	XMLName xml.Name `xml:"key"`
	Name    string   `xml:"name,attr"`
	Type    string   `xml:"type,attr"`
	Parts   []string `xml:"part"`
}

type Table struct {
	XMLName xml.Name `xml:"table"`
	Name    string   `xml:"name,attr"`
	Rows    []Row    `xml:"row"`
	Keys    []Key    `xml:"key"`
}

type Sql struct {
	XMLName xml.Name `xml:"sql"`
	Tables  []Table  `xml:"table"`
}

// func mysqlToPsqlType will return a string representing the postgresql type of the original type in SQL Designer
func mysqlToPsqlType(row Row) string {

	if row.Autoincrement > 0 {
		return "int"
	}

	if row.Datatype == "DATETIME" {
		return "time.Time"
	}

	if row.Datatype == "TIMESTAMP" {
		return "time.Time"
	}

	if row.Datatype == "TEXT" || row.Datatype == "MEDIUMTEXT" || strings.Index(row.Datatype, "VARCHAR") == 0 || strings.Index(row.Datatype, "CHAR") == 0 || strings.Index(row.Datatype, "ENUM") == 0 || strings.Index(row.Datatype, "BIT") == 0 {
		if row.Null == 0 {
			return "string"
		} else {
			return "sql.NullString"
		}
	}

	if row.Datatype == "INTEGER" {
		return "int"
	}

	if row.Datatype == "BOOLEAN" {
		return "bool"
	}

	if row.Datatype == "BYTEA" {
		//return "sql.RawBytes"
		return "string"
	}

	return row.Datatype
}

func sqlToGoName(bla string) string {
	return strings.Title(bla)
}

func searchString(a []string, search string) int {
	for i, v := range a {
		if v == search {
			return i
		}
	}
	return -1
}

func removeString(a []string, search string) []string {
	i := searchString(a, search)
	if i >= 0 {
		return append(a[:i], a[i+1:]...)
	}
	return a
}

// func printPsql will print all the postgresql code from the Sql structure
func printPsql(sql Sql) {
	tables := make([]string, 0)
	consts := make([]string, 0)

	for _, table := range sql.Tables {
		tablestr := fmt.Sprintf("type %s struct {\n", sqlToGoName(table.Name))
		var insertrows []string
		//insertrows := fmt.Sprintf("Insert%s", sqlToGoName(table.Name))
		for _, row := range table.Rows {
			typestr := mysqlToPsqlType(row)

			// add custom tags that are in comments
			comment := ""
			if len(row.Comment) > 0 {
				comment = " " + row.Comment
			}

			tablestr += fmt.Sprintf("\t%s\t%s\t`db:\"%s\" json:\"%s\"%s`", sqlToGoName(row.Name), typestr, row.Name, row.Name, comment)
			insertrows = append(insertrows, row.Name)

			for _, relation := range row.Relations {
				tablestr += fmt.Sprintf("\t// %s.%s", sqlToGoName(relation.Table), sqlToGoName(relation.Row))
			}
			tablestr += "\n"
		}

		for _, key := range table.Keys {
			if key.Type == "PRIMARY" {
				//creates += fmt.Sprintf("  PRIMARY KEY (\"%s\")\n", strings.Join(key.Parts, "\", \""))
				for _, part := range key.Parts {
					insertrows = removeString(insertrows, part)
				}
			}
		}
		tablestr += fmt.Sprintf("}")
		tables = append(tables, tablestr)

		insertrowsquoted := []string{}
		insertrowsvalues := []string{}
		updaterowsquoted := []string{}

		for _, rowname := range insertrows {
			insertrowsquoted = append(insertrowsquoted, fmt.Sprintf("\\\"%s\\\"", rowname))
			if rowname == "created_at" || rowname == "updated_at" {
				insertrowsvalues = append(insertrowsvalues, fmt.Sprintf("now()"))
			} else {
				insertrowsvalues = append(insertrowsvalues, fmt.Sprintf(":%s", rowname))
			}

			if rowname == "updated_at" {
				updaterowsquoted = append(updaterowsquoted, fmt.Sprintf("\\\"%s\\\" = now()", rowname))
			} else {
				if rowname != "created_at" {
					updaterowsquoted = append(updaterowsquoted, fmt.Sprintf("\\\"%s\\\" = :%s", rowname, rowname))
				}
			}
		}
		tablestr = fmt.Sprintf("const %s_InsertStr = \"%s\"", sqlToGoName(table.Name), strings.Join(insertrowsquoted, ", "))
		consts = append(consts, tablestr)

		tablestr = fmt.Sprintf("const %s_InsertValuesStr = \"%s\"", sqlToGoName(table.Name), strings.Join(insertrowsvalues, ", "))
		consts = append(consts, tablestr)

		tablestr = fmt.Sprintf("const %s_UpdateStr = \"%s\"", sqlToGoName(table.Name), strings.Join(updaterowsquoted, ", "))
		consts = append(consts, tablestr)
	}
	sort.Strings(tables)
	for _, tablestr := range tables {
		fmt.Println(tablestr + "\n\n")
	}
	for _, conststr := range consts {
		fmt.Println(conststr)
	}
}

func main() {
	filepath := config.DevDistPath + "/src/github.com/croll/arkeogis-server/db-schema.xml"
	//fmt.Println("Opening: " + filepath)
	in, err := ioutil.ReadFile(filepath)
	if err != nil {
		fmt.Println("Unable to open input file")
		os.Exit(1)
	}

	x := Sql{}

	err2 := xml.Unmarshal(in, &x)
	if err2 != nil {
		fmt.Printf("error: %v", err2)
		return
	}
	//fmt.Println("result: ", x)
	//fmt.Println("result len: ", len(x.Tables))

	fmt.Println("package model")
	fmt.Println()
	fmt.Println("import (")
	fmt.Println("	\"time\"")
	fmt.Println("	\"database/sql\"")
	fmt.Println(")")
	fmt.Println()

	printPsql(x)
}
